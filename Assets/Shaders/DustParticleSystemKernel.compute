#pragma kernel DustParticleSystemKernel

#include "DustParticleSystemCommon.cginc"
#include "NoiseSimplex.cginc"

//We define the size of a group in the x and y directions, z direction will just be one
#define thread_group_size_x 16
#define thread_group_size_y 16


//We keep three buffers accessed by the kernel, a constant buffer that is the same for every computation,
//an offset buffer with a value to offset the wave, and an output buffer that is written to by the kernel
Texture2D<float4> _colorByLife;
Texture2D<float4> _colorByVelocity;
RWStructuredBuffer<MeshStruct> emissionMesh;
RWStructuredBuffer<int> emissionMeshTris;
RWStructuredBuffer<ParticleStruct> output;
RWStructuredBuffer<int> kernelArgs;

SamplerState sampler_colorByLife;

float dt;
float fixedTime; //seconds
float3 origin;
float2 massNew;
float2 momentumNew;
float2 lifespanNew;

float inheritVelocityMult;
float3 initialVelocityDir;
float3 gravityIn;
float gravityModifier;
float jitter;
float randomizeDirection;

int emissionShape;
int emission;
float initialSpeed;
float3 emissionSize;
float scatterVolume;

float4 startColor;
float velocityColorRange;
int noiseType;
float3 noiseAmplitude;
float3 noiseScale;
float4 noiseOffset;
float4 noiseOffsetSpeed;

float4x4 emissionMeshMatrix;
int emissionMeshVertCount;
int emissionMeshTrisCount;

const float cellSize = 1.25;


//The kernel for this compute shader, each thread group contains a number of threads specified by numthreads(x,y,z)
//We lookup the the index into the flat array by using x + y * x_stride
[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void DustParticleSystemKernel(uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + id.y * thread_group_size_x * kernelArgs[0];

	float3 pos = output[idx].pos;
	float3 vel = output[idx].vel;
	float4 cd = output[idx].cd;
	float age = output[idx].age;
	float mass = output[idx].mass;
	float momentum = output[idx].momentum;

	// Randomness
	float r1 = rand(float2(id.x+.1, id.y));
	float r2 = rand(float2(id.x+.2, id.y));
	float r3 = rand(float2(id.x+0, id.y));
	float r4 = rand(float2(id.x+fixedTime, id.x));
	float3 randSphere = randomSpherePoint(float3(r1,r2,r3), scatterVolume);

	// Noise
	float3 simplexNoise = float3(0,0,0);
	float4 noiseCoord = float4(0,0,0,0);
	float4 noiseTranslate = noiseOffset + (noiseOffsetSpeed * float4(fixedTime,fixedTime,fixedTime,fixedTime));
	[call] switch(noiseType) {
		case 0:
			noiseCoord.xy = (pos.xy * noiseScale.xy) + noiseTranslate.xy;
			simplexNoise.xy = float2(snoise(noiseCoord.xy), snoise(noiseCoord.xy + 17.0));
			simplexNoise.xy *= noiseAmplitude.xy;
			break;
		case 1:
			noiseCoord.xyz = (pos * noiseScale) + noiseTranslate.xyz;
			simplexNoise.xyz = float3(snoise(noiseCoord.xyz), snoise(noiseCoord.xyz + 17.0), snoise(noiseCoord.xyz + 43.0));
			simplexNoise.xyz *= noiseAmplitude;
			break;
		case 2:
			noiseCoord = (float4(pos,1) * float4(noiseScale,1)) + noiseTranslate;
			simplexNoise = float3(snoise(noiseCoord), snoise(noiseCoord + 17.0), snoise(noiseCoord + 43.0));
			simplexNoise *= noiseAmplitude;
			break;
	}
	
	// Velocity
	float3 gravity = gravityIn * gravityModifier * dt;
	float3 velIn = simplexNoise + gravity;
	vel = (velIn * mass * dt) + vel * momentum;
	pos += vel;
	
	// Color
	float speed = length(vel);
	float2 coord = float2(fit(age, 0., output[idx].lifespan, 1., 0.), 0.5);
	float4 cdLife = _colorByLife.SampleLevel(sampler_colorByLife, coord, 0.0);
	coord = float2(fit(clamp(speed, 0., velocityColorRange), 0., velocityColorRange, 0., 1.), 0.5);
	float4 cdVel = _colorByVelocity.SampleLevel(sampler_colorByLife, coord, 0.0);
	cd = startColor * cdLife * cdVel;

	// Age
	age -= dt;

	// Spawn new particles
	if (age <= 0.0) 
	{
		[call] switch(emissionShape) 
		{
			// Procedural sphere
			case 0:
				vel = randSphere * initialSpeed * dt;
				pos = origin.xyz + (randSphere * emissionSize);
				pos += vel * r1 * jitter;
				break;

			// Mesh emission
			case 1:
				// Pick a random index into triangle buffer that's divisible by 3
			    int randId = int(round(floor(r4 * emissionMeshTrisCount) / 3.) * 3.);

				// Get the 3 id's that make up that triangle and generate a random point between them
				int3 tris = int3(emissionMeshTris[randId+0], emissionMeshTris[randId+1], emissionMeshTris[randId+2]);
				float3 a = output[tris.x].pos;
				float3 b = output[tris.y].pos;
				float3 c = output[tris.z].pos;
				pos = bayesianCoordinate(a, b, c, float2(r1,r2));
				
				// Velocity direction is the first vertex in the triangle...lazy
				vel = emissionMesh[tris.x].normal;
				vel = lerp(vel, normalize(vel + randSphere), randomizeDirection);
				vel *= initialSpeed * dt;

				// Jitter
				pos += vel * r1 * jitter;
				pos = mul(emissionMeshMatrix, float4(pos, 1.)).xyz;
				break;
		}
		
		// Inherit velocity from parent rigidbody or transform
		vel += initialVelocityDir * inheritVelocityMult * dt;

		float newLifespan = fit(rand(float2(id.x+.6, id.y)), 0., 1., lifespanNew.x, lifespanNew.y) * 2.; //*2 puts it into seconds
		age = newLifespan;

		output[idx].lifespan = newLifespan;
		output[idx].mass = fit(rand(float2(id.x+.7, id.y)), 0., 1., massNew.x, massNew.y);
		output[idx].momentum = fit(rand(float2(id.x+.8, id.y)), 0., 1., momentumNew.x, momentumNew.y);
	}

	output[idx].pos = pos;
	output[idx].vel = vel;
	output[idx].cd = cd;
	output[idx].age = age;

}